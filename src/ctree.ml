(* POY 4.0 Beta. A phylogenetic analysis program using Dynamic Homologies.    *)
(* Copyright (C) 2007  Andrés Varón, Le Sy Vinh, Illya Bomash, Ward Wheeler,  *)
(* and the American Museum of Natural History.                                *)
(*                                                                            *)
(* This program is free software; you can redistribute it and/or modify       *)
(* it under the terms of the GNU General Public License as published by       *)
(* the Free Software Foundation; either version 2 of the License, or          *)
(* (at your option) any later version.                                        *)
(*                                                                            *)
(* This program is distributed in the hope that it will be useful,            *)
(* but WITHOUT ANY WARRANTY; without even the implied warranty of             *)
(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              *)
(* GNU General Public License for more details.                               *)
(*                                                                            *)
(* You should have received a copy of the GNU General Public License          *)
(* along with this program; if not, write to the Free Software                *)
(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301   *)
(* USA                                                                        *)

(** ctree.ml - this file implements a linear time randomized 
* algorithm to create a consensus tree for a given set of trees.
* Ref: A Linear Time Majority Algorithm for Majority Tree, Amenta,
* Clarke and St. John, LNCS ... Some of the terminology used here reflects
* the terminology used in that paper. *)
let () = SadmanOutput.register "Ctree" "$Revision: 1644 $"


(* Indicates a double collision in the hash table. *)
exception Double_Collision 

module Hash_tbl = struct 

    (* The hash table record that contains the id generated by h2, the
    * number of times the partition occurs so far and the number of elements
    * in the partition. *)
    type hash_tbl_record = { id : int ; 
                             (* identity generated by h2 *)
                             count : int ;
                             (* number of times this bi-partition occurs. *)
                             size : int ;
                             (* number of elements in the bi-partition. *) 
                             index : int
                             (* if the split was of size 1, then
                                this field holds the index of the leaf node.
                                since all legal indexes start at 0, this field
                                needs to be initialized to -1. *) }
                             
    (* The array to hold the list of records. *)
    type hash_tbl = { records : hash_tbl_record list array ;
                      (* the records of the hash table. *)
                      h1_params : int array ;
                      (* the a_i's for h1. *)
                      h2_params : int array ;
                      (* the a_i's for h2. *) 
                      m1 : int ;
                      (* prime number >= num_trees * num_nodes_per_tree *)
                      m2 : int 
                      (* prime number atleast twice as large as m1 *) }

    (* An empty record. *)
    let empty_record = { id = 0 ; 
                        count = 0 ; 
                        size = 0 ; 
                        index = -1 } 
    
    (** [print_record recd] 
        @return (), prints the passed in record as a side-effect. *)
    let print_record recd = 
        print_string ("{ id = " ^ (string_of_int recd.id) ^ 
                       " ; count = " ^ (string_of_int recd.count) ^
                       " ; size = " ^ (string_of_int recd.size) ^ 
                       " ; index = " ^ (string_of_int recd.index) ^ " }")
    
    (** [make h1_p h2_p m1 m2]
        @param h1_p the parameters for the universal hash function h1.
        @param h2_p the parameters for the universal hash function h2.
        @param m1 a prime number greater than the number of trees *
            number_of_nodes_per_tree.
        @param m2 a prime number greater than m1. 
        @return a newly created hash table with n empty records and the given
            parameters. *)
    let make h1_p h2_p m1 m2 = 
        (* make sure the parameters are consistent. *)
        assert((m1 > 0) && (m2 > m1)) ;
        assert((Array.length h1_p) = (Array.length h2_p)) ;
        for i = 0 to (Array.length h1_p) - 1 do
            assert((h1_p.(i) >= 0) && (h1_p.(i) < m1)) ;
            assert((h2_p.(i) >= 0) && (h2_p.(i) < m2)) ;
        done ;
        (* Make a hash table with empty records. *)
        { records = Array.make m1 [] ;
          h1_params = h1_p ;
          h2_params = h2_p ;
          m1 = m1 ;
          m2 = m2 }
          
    (** [populate root_id (rtree, index_tbl, node_hashes) hash_tbl]
        @param root_id the root node that identifies the tree.
        @param rtree the rooted forest.
        @param index_tbl the index of the leaf nodes. 
        @param node_hashes create a hash table to store the node-hashes. 
         this table is need to efficiently compute the hash of an interior 
         node. 
        @return populates the hash table with the partitions of the tree. *)
    let populate root_id (rtree, index_tbl, node_hashes) hash_tbl =         
        (* function to add the hash of the node to the hash table. *)
        let visit_op node_id hash_tbl =
            (* function to update the record list. *)
            let rec update_recd_lst recd recd_lst = 
                (* if the record list is empty. *)
                match recd_lst with
                (* add the record to the list. *)
                | [] -> [ recd ] 
                (* if the record list has records. insert sort into the list
                * based on the ids. *)
                | record :: records -> 
                begin
                    let id1 = recd.id in
                    let id2 = record.id in
                    begin
                        match (compare id1 id2) with
                        | x when (x > 0) ->                
                            record :: (update_recd_lst recd records)
                        | x when (x < 0) ->
                                recd :: recd_lst
                        | _ -> (* x when (x = 0) *) 
                            (* if there was a double collision, exit. *)
                            if ( (recd.size != record.size) ||
                                 (recd.index != record.index) ) then 
                                (raise Double_Collision)
                            else
                                (* update the record. *)
                                let record = { record with 
                                               count = record.count + 1 } in
                                    record :: records 
                    end
                end
            in
            match (Rtree.get_node node_id rtree) with
            (* if the node being visited is a leaf. *)
            | Rtree.Leaf(_) ->
                (* get the index of the node into the hash-table and
                * the hash of the bi-partition. *)
                let node_indx = (Hashtbl.find index_tbl node_id) in
                let node_hash = (hash_tbl.h1_params.(node_indx)) in
                let split_hash = (hash_tbl.h2_params.(node_indx)) in
                let _ = (Hashtbl.add node_hashes node_id 
                            (node_hash, split_hash, 1)) in
                let recd = { id = split_hash ;
                             count = 1 ;
                             size = 1 ;
                             (* assign the index. *)
                             index = node_indx } in
                (* check for the split in the hash table and update the 
                * record list. *)
                let recd_lst = hash_tbl.records.(node_hash) in
                (* update the list with the current split. *)
                let recd_lst = (update_recd_lst recd recd_lst) in
                begin
                    hash_tbl.records.(node_hash) <- recd_lst ;
                    hash_tbl
                end
            (* otherwise, if the node is an interior node or a root node. *)
            | Rtree.Interior(nd_id, _, l_id, r_id) 
            | Rtree.Root(nd_id, l_id, r_id) ->
                (* compute the node and split hashes. These are computed
                * from the hashes of the left and right children. Since,
                * we visit the tree in post-order, these values should
                * already be computed. *)
                let (lnh, lsh, lss) = Hashtbl.find node_hashes l_id in
                let (rnh, rsh, rss) = Hashtbl.find node_hashes r_id in
                let nh = (lnh + rnh) mod hash_tbl.m1 in
                let sh = (lsh + rsh) mod hash_tbl.m2 in
                let ss = lss + rss in
                let _ = Hashtbl.add node_hashes nd_id (nh, sh, ss) in
                (* leave the index of the record at -1 *)
                let recd = { empty_record with id = sh ;
                             count = 1 ;
                             size = ss } in
                (* check for the split in the hash table and update the 
                * record list. *)
                let recd_lst = hash_tbl.records.(nh) in
                (* update the list with the current split. *)
                let recd_lst = (update_recd_lst recd recd_lst) in
                begin
                    hash_tbl.records.(nh) <- recd_lst ;
                    hash_tbl
                end
        in
        let _ = 
            (Rtree.post_order_node_visitor visit_op root_id rtree hash_tbl) 
        in
            (node_hashes, hash_tbl) 
                                                      
    (* [get_data (nd_hash, sp_hash) hash_tbl]
       @return the hash table record associated with the node. *)
    let get_data (nd_hash, sp_hash) hash_tbl = 
        let recd_lst = hash_tbl.records.(nd_hash) in
        let find_fn recd = (recd.id = sp_hash) in
        let recd = (List.find find_fn recd_lst) in
            (recd.count, recd.size, recd.index) 
        
end 

(* Indicates an invalid node id. *)
exception Invalid_Node_Id

(* A flexible node type to allow for trees with polytomies. *)
type node = Root of int * int list 
            (* (id, child id list) *)
          | Interior of int * int * int list 
            (* (id, parent id, child id list) *)
          | Leaf of int * int 
            (* (id, parent) *)

(* The forest of consensus trees or better still a consensus forest
* could be represented using this type. *)
type c_tree = { c_topo : node All_sets.IntegerMap.t ;
                (* the topology of the consensus forest. *)
                roots : All_sets.Integers.t 
                (* the set of roots of the consensus forest. *) }

(* the empty consensus forest. *)
let empty = { c_topo = All_sets.IntegerMap.empty ;
              roots = All_sets.Integers.empty }

(*************************** GET FUNCTIONS ***************************)

(** [get_id node] 
    @param node the node whose id is desired
    @return id of the node. *)
let get_id node =
    match node with
    | Root(id, _) -> id
    | Leaf(id, _) -> id 
    | Interior(id, _, _) -> id 

(** [get_node id ctree]
    @param id id of the node desired.
    @param tree tree to which the node belongs
    @return returns the node associated with the id.
    @raise Invalid_Node_Id, if the id is not a valid id. *)
let get_node id tree = 
    try 
        (All_sets.IntegerMap.find id tree.c_topo)
    with 
        | Not_found -> raise Invalid_Node_Id

(** [get_parent nd_id ctree]
    @return the id of the parent node. *)
let get_parent nd_id ctree = 
    match get_node nd_id ctree with
    | Leaf(_, pid) -> pid 
    | Root(_, _) -> raise (Failure "Cannot get parent of root node.")
    | Interior(_, pid, _) -> pid
        
(** [is_node id ctree]
    @param id id of the node desired.
    @param tree tree to which the node belongs
    @return returns true when a node with the given id exists in the tree,
        returns false otherwise. *)
let is_node id tree = 
    (All_sets.IntegerMap.mem id tree.c_topo)
    
        
(** [is_root id ctree]
    @param id the id being checked whether it belongs to the root or not. 
    @param ctree the rooted tree in which id is either a root or not. *)
let is_root id ctree = 
    (* get the node corresponding to the id. *)
    match (get_node id ctree) with
    (* if it is a root node, make sure it exists in the root set and 
    * return true. *)
    | Root(_) -> 
        assert(All_sets.Integers.mem id ctree.roots) ;
        true 
    (* otherwise, return false. *)
    | _ -> false 

(** [is_leaf id ctree] 
    @param id the id of the node being checked to determine whether it
            is a leaf or not.
    @param ctree the rooted tree in which the id belongs to a leaf node or
            not. *)
let is_leaf id ctree = 
    (* get the node. *)
    match (get_node id ctree) with
    (* if the node is a leaf, then return true. *)
    | Leaf(_) -> true 
    (* otherwise false. *)
    | _ -> false 

(********************* BEGIN - UNSAFE OPS ****************************)

(** [add_node node ctree]
    @param node the node that needs to be added to the tree.
    @param tree the tree to which the node is being added.
    @return the tree with the node added.
    This function does not check whether the node is already
    present in the tree or not. If the node is already present then
    the tree is returned unmodified. *) 
let add_node node ctree = 
    let id = (get_id node) in
    let new_topo = (All_sets.IntegerMap.add id node ctree.c_topo) in
    let ctree = { ctree with c_topo = new_topo } in
    (* check whether the added node was a root. *)
    match node with
    | Root(_) -> 
        (* if it is, add it to the root set. *)
        { ctree with roots = All_sets.Integers.add id ctree.roots }
        (* else, do nothing. *)
    | _ -> ctree 

(** [add_nodes nodes ctree]
    @param nodes list of nodes that need to be added to the tree.
    @param btree tree to which the nodes are being added.
    @return tree with the list of nodes added. Older nodes with the
    same ids will be overwritten. *)
let add_nodes nodes ctree = 
    let f ctree node = (add_node node ctree) in
        (List.fold_left f ctree nodes)

(** [add_child nd_id child_id ctree]
    @return a ctree in which nd_id had a child child_id. *)
let add_child nd_id child_id ctree = 
    let node = (get_node nd_id ctree) in
    match node with
    | Root(_, chld_lst) ->
        (add_node (Root(nd_id, child_id :: chld_lst)) ctree)
    | Interior(_, pid, chld_lst) ->
        (add_node (Interior(nd_id, pid, child_id :: chld_lst)) ctree)
    | Leaf(_, pid) -> 
        (add_node (Interior(nd_id, pid, [child_id])) ctree)

(** [set_parent nd_id pid ctree]
    @return a ctree in which nd_id has parent set to pid. *)
let set_parent nd_id pid ctree = 
    let node = get_node nd_id ctree in
    match node with
    | Root(_, chld_lst) ->
        raise (Failure "Cannot set parent of root node.")
    | Interior(_, _, chld_lst) ->
        (add_node (Interior(nd_id, pid, chld_lst)) ctree)
    | Leaf(_, pid) -> 
        (add_node (Leaf(nd_id, pid)) ctree)

(** [remove_child nd_id chld_id ctree]
    @return a new ctree in which nd_id does not have chld_id as its child. *)
let remove_child nd_id chld_id ctree = 
    let node = get_node nd_id ctree in
    let filter_fn nd_id = (nd_id != chld_id) in
    match node with
    | Root(_, chld_lst) ->
        let n_chld_lst = List.filter filter_fn chld_lst in
            (add_node (Root(nd_id, n_chld_lst)) ctree) 
    | Interior(_, pid, chld_lst) ->
        let n_chld_lst = List.filter filter_fn chld_lst in
            (add_node (Interior(nd_id, pid, n_chld_lst)) ctree) 
    | Leaf(_, _) ->
        raise (Failure "Cannot replace child of leaf node.")
        
(********************** END - UNSAFE OPS *****************************)

(** [pre_order_node_visitor visitor_op node_id ctree accum]
    @param visit_op function to applied to each node as it is visited.
    @param node_id the node whose children are visited in pre-order. When
        node_id is root, then all the nodes of the tree are visited; 
        otherwise only the children of the node are visited.
    @param ctree the tree whose nodes are being visited.
    @param accum the accumulator that accumulates the results of all the 
                 visits. 
    @return the accumulator with the results of the node visit. *)
let pre_order_node_visitor visit_op node_id ctree accum = 
    (* function to visit the node. *)
    let visit node_id accum = 
        (visit_op node_id accum) 
    in
    (* function to visit the node and process the children. *)
    let rec visit_node_n_children node_id chld_lst accum =
        (* visit the node. *)
        let accum = (visit node_id accum) in
        (* visit the children. *)
        let accum = (List.fold_left traverse accum chld_lst) in
            (* return the accumulator. *)
            accum 
    (* function to traverse the tree in pre-order. *)
    and traverse accum node_id = 
        (* get the node corresponing to the start node id. *)
        match (get_node node_id ctree) with
        (* if it is the root node. *)
        | Root(root_id, chld_lst) -> 
            (* make sure the root is included in the roots set. *)
            assert(is_root root_id ctree) ;
            (* visit the node and its children. *)
            (visit_node_n_children root_id chld_lst accum)
        (* if it is an interior node. *)
        | Interior(int_id, _, chld_lst) ->
            (* visit the node and its children. *)
            (visit_node_n_children int_id chld_lst accum)
        (* if it is a leaf node *)
        | Leaf(leaf_id, _) -> 
            (* just, visit the node. *)
            (visit leaf_id accum) 
    in
        (* traverse the tree starting at the node_id. *)
        (traverse accum node_id)

(** [post_order_node_visitor visit_op node_id ctree accum]
    @param visit_op function to applied to each node as it is visited.
    @param node_id the node whose children are visited in pre-order. When
        node_id is root, then all the nodes of the tree are visited; 
        otherwise only the children of the node are visited.
    @param ctree the tree whose nodes are being visited.
    @param accum the accumulator that accumulates the results of all the 
                 visits. 
    @return the accumulator with the results of the node visit. *)
let post_order_node_visitor visit_op node_id ctree accum = 
    (* function to visit the node. *)
    let visit node_id accum = 
        (visit_op node_id accum) 
    in
    (* function to visit the node and process the children. *)
    let rec visit_node_n_children node_id chld_lst accum =
        (* visit the children. *)
        let accum = (List.fold_left traverse accum chld_lst) in
        (* visit the node. *)
        let accum = (visit node_id accum) in
            (* return the accumulator. *)
            accum 
    (* function to traverse the tree in pre-order. *)
    and traverse accum node_id = 
        (* get the node corresponing to the start node id. *)
        match (get_node node_id ctree) with
        (* if it is the root node. *)
        | Root(root_id, chld_lst) -> 
            (* make sure the root is included in the roots set. *)
            assert(is_root root_id ctree) ;
            (* visit the node and its children. *)
            (visit_node_n_children root_id chld_lst accum)
        (* if it is an interior node. *)
        | Interior(int_id, _, chld_lst) ->
            (* visit the node and its children. *)
            (visit_node_n_children int_id chld_lst accum)
        (* if it is a leaf node *)
        | Leaf(leaf_id, _) -> 
            (* just, visit the node. *)
            (visit leaf_id accum) 
    in
        (* traverse the tree starting at the node_id. *)
        (traverse accum node_id) 

(** [get_num_nodes ctree]
    @return the number of nodes in the subtree rooted at root_id. *)
let get_num_nodes root_id ctree = 
    let visit_op node_id num_nodes = 
        (num_nodes + 1) 
    in
        (pre_order_node_visitor visit_op root_id ctree 0) 

(** [print_node node]
    @return prints the node. *)
let print_node node =
    let print_lst lst = 
        let print_fn item = 
            print_string ((string_of_int item) ^ " ") in
            List.iter print_fn lst
    in
    match node with
    | Leaf(id, pid) ->
         print_endline ("Leaf(" ^ (string_of_int id) ^ ", " ^
                               (string_of_int pid) ^ ")") 
    | Root(id, chld_lst) ->
         print_string ("Root(" ^ (string_of_int id) ^ ", ") ;
         print_lst chld_lst ;
         print_endline ")" 
    | Interior(id, pid, chld_lst) ->           
         print_string ("Interior(" ^ (string_of_int id) ^ ", ") ;
         print_string ((string_of_int pid) ^ " ") ;
         print_lst chld_lst ;
         print_endline ")" 

(** [build_ctree rtree_nd_hash_lst index_tbl sp_tbl]
    @param rtree_nd_hash_lst the rooted tree and corresponding node_hash 
        list.
    @param index_tbl the indexes of the leaf nodes.
    @param sp_tbl the hash_table with the split counts.
    @return the consensus tree of the trees in the rtree_nd_hash_lst. *)
let attempt_ctree maj num_nodes rtree_nd_hash_lst sp_tbl =
    (* function to generate the ids of the nodes in the ctree. *)
    let id_fn = 
        let x = ref 0 in
            (fun () -> (incr x; !x))
    in
    (* The table of node hashes to the index in the ctree. Used to 
    * determine whether a node already exists in the ctree or not. *)
    let nd_hashes_index_tbl = Hashtbl.create num_nodes in
    (* Hash table to store the size of paritions at consensus tree
    * nodes. *)
    let nd_size_tbl = Hashtbl.create num_nodes in
    (* function to determine whether a node exists in the ctree 
    * corresponding to the node_hashes. *)
    let has_node (nd_hash, sp_hash) = 
        (Hashtbl.mem nd_hashes_index_tbl (nd_hash, sp_hash)) 
    in
    (* function to get the index in the ctree, given node and 
    * split hashes. *)
    let get_node_index (nd_hash, sp_hash) = 
        (Hashtbl.find nd_hashes_index_tbl (nd_hash, sp_hash))
    in
    (* function to save a node's index in the ctree. The node is 
    * identified using its node and split hashes. *)
    let save_node_index (nd_hash, sp_hash) index = 
        (Hashtbl.add nd_hashes_index_tbl (nd_hash, sp_hash) index)
    in
    (* function to incorporate the data of one input tree into the 
    * consensus tree. *)
    let update_consensus_with_tree (croot_id, ctree)
                                   (root_id, rtree, nd_hashes) = 
        (* function to process the node. *)
        let visit_op nd_id (pid, ctree) = 
            let (nd_hash, sp_hash, _) = Hashtbl.find nd_hashes nd_id in
            let (count, size, _) = 
                Hash_tbl.get_data (nd_hash, sp_hash) sp_tbl in
            (* if the node is a majority node. *)
            if ( count >= maj ) then begin
                (* Is the node in the consensus tree? *)
                if (has_node (nd_hash, sp_hash)) then begin
                    let index = get_node_index (nd_hash, sp_hash) in
                    (* update the parent. *)
                    if (not (is_root index ctree)) then begin
                        let cpid = (get_parent index ctree) in
                        let cpsize = Hashtbl.find nd_size_tbl cpid in
                        let psize = Hashtbl.find nd_size_tbl pid in
                            match psize < cpsize with
                            | true ->
                                (* better parent found. *)
                                assert(not (pid = cpid)) ;
                                let ctree = (set_parent index pid ctree) in
                                let ctree = (remove_child cpid index ctree) in
                                let ctree = (add_child pid index ctree) in
                                    (index, ctree)
                            | false ->
                                (* do nothing. *)
                                (index, ctree)
                    end else
                        (index, ctree)
                end else begin
                    (* create a new node for this majority node. *)
                    assert(size > 0) ;
                    let index = id_fn () in
                    let _ = (save_node_index (nd_hash, sp_hash) index) in
                    match size with
                    | 1 -> 
                        let ctree = (add_node (Leaf(index, pid)) ctree) in
                        let ctree = (add_child pid index ctree) in
                        let _ = Hashtbl.add nd_size_tbl index 1 in
                            (index, ctree)
                    | _ ->
                        let ctree = 
                            (add_node (Interior(index, pid, [])) ctree) in
                        let ctree = (add_child pid index ctree) in
                        let _ = Hashtbl.add nd_size_tbl index size in
                            (index, ctree)
                end
            end else
                (* do nothing. *)
                (pid, ctree)
        in
        (* function to perform a pre-order-traversal of the rtree. *)
        let rec traverse nd_id rtree (pid, ctree) =
            (* visit the node. *)
            let (pid, ctree) = visit_op nd_id (pid, ctree) in
            (* visit its children. *)
            match Rtree.get_node nd_id rtree with
            | Rtree.Root(_, lid, rid) 
            | Rtree.Interior(_, _, lid, rid) ->
                let _, ctree = traverse lid rtree (pid, ctree) in
                let pid, ctree = traverse rid rtree (pid, ctree) in
                    pid, ctree
            | Rtree.Leaf(_, _) ->
                (pid, ctree) 
        in
            (* make sure root_id is a root id. *)
            assert(Rtree.is_root root_id rtree) ;
            (* visit the root. *)
            let (_, ctree) = traverse root_id rtree (croot_id, ctree) in
                (croot_id, ctree)
    in
        (* Build the root of the consensus tree. *)
        match rtree_nd_hash_lst with
        | [] -> (-1, empty, nd_size_tbl)
        | (root_id, rtree, nd_hashes) :: _ -> 
            (* get the hash for the root_id. *)
            let (nd_hash, sp_hash, sp_size) = Hashtbl.find nd_hashes root_id in
            let croot_id = (id_fn ()) in
            let ctree = (add_node (Root(croot_id, [])) empty) in
            let _ = Hashtbl.add nd_size_tbl croot_id sp_size in
            let _ = (save_node_index (nd_hash, sp_hash) croot_id) in
            (* Build the rest of the consensus tree. *)
            let croot_id, ctree =
                List.fold_left update_consensus_with_tree 
                               (croot_id, ctree) 
                               rtree_nd_hash_lst in
                (croot_id, ctree, nd_size_tbl) 

(** [verify_ctree (croot_id, ctree, nd_size_tbl)] 
    @param croot_id the root of the ctree.
    @param ctree the consensus tree.
    @nd_size_tbl the table containing the sizes of the partitions
        of each node in the original-hash-table built by consensus
        tree algorithm.
    @return a boolean to indicate whether the consensus tree was built 
        correctly or has a double-collision. *) 
let verify_ctree (croot_id, ctree, nd_size_tbl) = 
    (* function to make a post-order-traversal and verify the 
    * consensus tree. *)    
    let rec traverse nd_id = 
        (* get the node. *)
        let node = get_node nd_id ctree in
        match node with 
        (* if the node is a root or an interior node, compute the size of the
        * split and check against the nd_size_tbl. *)
        | Root(_, chld_lst)
        | Interior(_, _, chld_lst) ->
            (* get the results. *)
            let res = List.map traverse chld_lst in
            let statuses, sizes = List.split res in
            let status = List.fold_left (&&) true statuses in
                if (not status) then
                    (raise Double_Collision)
                else
                    let actual_size = List.fold_left (+) 0 sizes in
                    let expected_size = (Hashtbl.find nd_size_tbl nd_id) in
                        (actual_size = expected_size, actual_size)
        (* if the node is a leaf, make sure it has size 1. *)
        | Leaf(_, _) -> 
            assert((Hashtbl.find nd_size_tbl nd_id) = 1) ;
            (true, 1) 
    in
        try
            (* Verify the tree. *)
            let (status, _) = traverse croot_id in
                assert(status) ;
                status
        with
        (* Got double collison, return false. *)
        | Double_Collision -> false
        (* Unexpected exn, raise it as is. *)
        | exn -> raise exn


(** [build_ctree num_nodes rtree_lst]
    @param maj the number of trees in which a partition must appear, in order 
    to appear in the final tree, 
    @param num_nodes number of nodes in each of the rooted trees. Note that
    all these trees need to have the same number of nodes.
    @param rtree_lst = (root_id, rtree) the list of the rooted trees on the 
    same set of leaves. 
    @return A consensus tree of all the trees in the rtree_lst is returned. *)
let build_ctree  maj num_nodes rtree_lst = 
    (* maximum number of tries before a good consensus tree is found. *)
    let max_tries = 15 in
    (* Initialize the random number generator. *)
    let _ = Random.self_init () in
    (* This factor determines the probability of a double collision. 
    * prob = 1 / safety_factor. Large safety factor is good, but it could lead
    * to overflow issues. *)
    let safety_factor = 100000 in
    (* get the number of trees. *)
    let num_trees = List.length rtree_lst in
    (* make sure maj is correct. *)
    assert(maj > (num_trees / 2)) ;
    (* make sure there are atleast two trees. *)
    assert(num_trees > 1) ;
    (* get the prime numbers m1 and m2 of the hash functions. *)
    let total_nodes = (num_nodes * num_trees) in
    let m1 = Primes.Probable.next_prime_gt total_nodes in
    (* potential overflow. *)
    let m2 = Primes.Probable.next_prime_gt (safety_factor * total_nodes) in
    (* get the number of leaves. *)
    let num_leaves = (num_nodes + 1) / 2 in
    (* create the index table. *)
    let (rt_id, rtree) = List.hd rtree_lst in
    let index_tbl = 
        Rtree.index_nodes (0, num_leaves) num_nodes rt_id rtree in
    (* Attempt to create a consensus tree. *)
    let rec attempt trial_num = 
        (* create the parameters for the hash_table. *)
        let h1_p = Array.make num_leaves 0 in
        let h2_p = Array.make num_leaves 0 in
        let _ = for i = 0 to num_leaves - 1 do
                    h1_p.(i) <- (Random.int m1) ;
                    h2_p.(i) <- (Random.int m2)
                done 
        in
        (* create the actual split-hash table. *)
        let sp_hash_tbl = Hash_tbl.make h1_p h2_p m1 m2 in
        (* populate the split-hash table. *)
        let populate (rt_id, rtree) = 
            (* create the node_hashes tbl. *)
            let node_hashes = Hashtbl.create num_nodes in
            let node_hashes, _ = Hash_tbl.populate rt_id 
                                  (rtree, index_tbl, node_hashes)
                                  sp_hash_tbl in
                (rt_id, rtree, node_hashes) 
        in
        let rt_nd_hash_lst = List.map populate rtree_lst in
        (* Attempt to build the ctree. *)
        try
            let croot_id, ctree, nd_sz_tbl = 
                attempt_ctree maj num_nodes rt_nd_hash_lst sp_hash_tbl in
            let verified = (verify_ctree (croot_id, ctree, nd_sz_tbl)) in
                begin
                    match verified with
                    | true -> (croot_id, ctree) 
                    | false -> 
                        if ( trial_num < max_tries ) then
                            (attempt (trial_num + 1)) 
                        else
                            raise (Failure "max_tries exceeded.")
                end
        with
        | Double_Collision -> (attempt (trial_num + 1))
        | xn -> (raise xn)
    in
        (attempt 1)
